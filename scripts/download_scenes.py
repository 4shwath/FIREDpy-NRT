import os
from datetime import datetime, timedelta
import geopandas as gpd
import shapely
import sys
import requests
from tqdm import tqdm
import zipfile
import pandas as pd
import argparse
from landsatxplore.api import API
from landsatxplore.earthexplorer import EarthExplorer
import tarfile

from config import Config


# Enter your credentials to access the Copernicus Data Space Ecosystem
config = Config()


def download_product(product, output_file):
    '''
    Downloads a product from Sentinel-2 as a ZIP file.

    Requires a pandas Series object containing a product's metadata.
    Requires an output file name to write the downloaded data.
    '''
    product_id = product['Id']
    timeout = 300
    
    url = f"https://zipper.dataspace.copernicus.eu/odata/v1/Products({product_id})/$value"
    headers = {"Authorization": f"Bearer {config.access_token}"}
    session = requests.Session()
    session.headers.update(headers)

    try:
        with session.get(url, headers=headers, stream=True, timeout=timeout) as response:
            response.raise_for_status()
            with open(output_file, 'wb') as file:
                for chunk in tqdm(response.iter_content(chunk_size=8192), desc="Downloading"):
                    if chunk:
                        file.write(chunk)
    
    except requests.Timeout:
        print(f"Skipping product due to timeout.")
    except requests.RequestException as e:
        print(f"Error downloading product: {e}")


def extract_zip_product(output_directory, zip_file):
    '''
    Extracts all data from a ZIP file.

    Requires an output directory in which to extract the files.
    Requires a ZIP file to extract data from.
    '''
    with zipfile.ZipFile(zip_file, 'r') as zip_ref:
        zip_ref.extractall(output_directory)


def extract_tar_product(tar_file):
    '''
    Extracts all data from a TAR file.

    Requires an output directory in which to extract the files.
    Requires a TAR file to extract data from.
    '''
    output_dir = tar_file
    os.mkdir(output_dir)
    tar_file += '.tar'
    try:
        with tarfile.open(tar_file, 'r') as tar:
            tar.extractall(output_dir)
            os.remove(tar_file)
    except tarfile.TarError as e:
        print(f'Tarfile extraction failed: {e}')


def get_sentinel(event_id,
                 aoi, 
                 search_period_start, 
                 search_period_end, 
                 product_type,
                 max_cloud_cover,
                 collection_name="SENTINEL-2"):
    """
    Queries Sentinel-2 images for a specified fire event within a given time frame. 
    For downloading images, set the download_scenes parameter in the config file to True.

    This function connects to the Sentinel Copernicus Data Space's Catalogue, searches for available images for the specified event
    within the defined date range, and downloads the images if found.

    Parameters:
        event_id (str): A string identifying the fire event for which to download images.
        aoi (str): The Area of Interest (AOI) for downloading images, as generated by the get_footprint function.
        search_period_start (str or datetime.datetime): The start date of the time range for which images are sought.
            Can be either a Python datetime object or a string in the format 'YYYY-MM-DD'.
        search_period_end (str or datetime.datetime): The end date of the time range for which images are sought.
            Can be either a Python datetime object or a string in the format 'YYYY-MM-DD'.
        product_type (str): The Sentinel product type to search for. Possible values: {'S2MSI2A', 'S2MSI1C', 'S2MS2Ap'}.
        collection_name (str, optional): The Data Collection to search for images. Default is "SENTINEL-2".

    """
    print(f"\nSearching for Sentinel images for event ID: {event_id}")
        
    # base URL of the product catalogue
    catalogue_odata_url = "https://catalogue.dataspace.copernicus.eu/odata/v1"

    search_query = (
        f"{catalogue_odata_url}/Products?$filter=Collection/Name eq '{collection_name}' "
        f"and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{product_type}') "
        f"and OData.CSC.Intersects(area=geography'SRID=4326;{aoi}') "
        f"and Attributes/OData.CSC.DoubleAttribute/any(att:att/Name eq 'cloudCover' and att/OData.CSC.DoubleAttribute/Value le {max_cloud_cover}) "
        f"and ContentDate/Start ge {search_period_start} and ContentDate/Start le {search_period_end}"
        f"&$top=50"
        )

    response = requests.get(search_query).json()
    products = pd.DataFrame.from_dict(response["value"])
    products = products[products['ContentLength'] > 0].reset_index(drop=True)

    # If any sentinel product is found
    if len(products) > 0:
        print(f"\n{len(products)} Sentinel products found for event {event_id}")

       # Create directories for saving the images or the footprints
        out_dir = os.path.join(config.data_dir, event_id)
        if not os.path.exists(out_dir):
                os.mkdir(out_dir)
        output_directory = os.path.join(out_dir, "Sentinel")
        if not os.path.exists(output_directory):
                os.mkdir(output_directory)

        # Download products
        if config.download_scenes:
            print(f"\nDownloading Sentinel products for event{event_id} to {output_directory}")

            # Zip file to store the downloaded product
            output_file = f"{output_directory}/temp_product.zip"

            for i in range(len(products)):
                product = products.loc[i, :]
                print(f'Checking product [{i+1}/{len(products)}]')

                if product['Name'] in os.listdir(output_directory):
                    print('Product already exists in directory! Skipping...')
                    continue

                print('Downloading product...')
                download_product(product, output_file)
                extract_zip_product(output_directory, output_file)           

    else:
        print(f"\nNo Sentinel-2 scenes found for the fire event {event_id}")
    

def get_landsat(event_id,
                footprint, 
                 start_date, 
                 end_date):   
    """
    Downloads Landsat images for a specified event within a given time frame.

    This function connects to the landsatxplore API and searches for available images for the specified 
    event within the defined date range.
    
    For downloading images, set the download_scenes parameter in the config file to True.

    Parameters:
        event_id (str): A string identifying the fire event for which to download images.
        footprint (tuple): The Area of Interest (AOI) for downloading images in the form of (xmin, ymin, xmax, ymax) of the bounding box.
        start_date (datetime.datetime): The start date of the time range for which images are sought.
        end_date (datetime.datetime): The end date of the time range for which images are sought.

    Returns:
        None: This function does not return any values. It downloads images and saves them to disk.

    """

    print(f"searching for Landsat images for event ID: {event_id}")

    # initialize the API
    api = API(config.username_landsat, config.password_landsat)

    # Search for Landsat 8 scenes
    # source: https://github.com/yannforget/landsatxplore/blob/master/landsatxplore/api.py
    # TODO: modify the dataset param in search based on the input platform param
    scenes = api.search(
        dataset='landsat_ot_c2_l1',
        bbox=footprint,
        start_date=start_date.strftime('%Y-%m-%d'),
        end_date=end_date.strftime('%Y-%m-%d'),
        max_cloud_cover=config.max_cloud_cover
    )

    # Process the search results
    if scenes:
        print(f"{len(scenes)} Landsat products found for event {event_id}")

        # create output directories
        out_dir = os.path.join(config.data_dir, event_id)
        if not os.path.exists(out_dir):
                os.mkdir(out_dir)
        output_directory = os.path.join(out_dir, "Landsat")
        if not os.path.exists(output_directory):
                os.mkdir(output_directory)

        # download products
        if config.download_scenes:
            print(f"Downloading Landsat products for event: {event_id} to {output_directory} ...")
            ee = EarthExplorer(config.username_landsat, config.password_landsat)

            for i in range(len(scenes)):
                product = scenes[i]
                print(f'Checking product [{i+1}/{len(scenes)}]')

                if product['display_id'] in os.listdir(output_directory):
                    print('Product already exists in directory! Skipping...')
                    continue

                print('Downloading product...')
                ee.download(product['display_id'], output_dir=output_directory)
                output_file = f'{output_directory}/{product["display_id"]}'
                extract_tar_product(output_directory, output_file)

            ee.logout()

    else:
        print(f"No Landsat scenes found for the fire event {event_id}")

    # Logout from the API
    api.logout()


def parse_shp(filename, fid):
    """
    Parses a shapefile of fire events to extract specific fire event information.
    The shapefile is the output of FiredPy package.
    """
    
    fires = gpd.read_file(filename)
    if not str(fid) in fires['id'].values:
         print("invalid fire ID provided! Make sure the ID exists in the fire events shapefile")
         sys.exit()
    fire_event = fires[fires['id'] == str(fid)]
    start_date = datetime.strptime(fire_event['ig_date'].values[0], "%Y-%m-%d")
    end_date = datetime.strptime(fire_event['last_date'].values[0], "%Y-%m-%d")
    footprint = fire_event['geometry'].values[0]

    return fid, start_date, end_date, footprint


def main(event_id, satellite):
    """
    Note:
        Make sure the following variables are correctly configured in the "config" module:
        - data_dir
        - download_scenes
        - delta_days_sentinel
        - delta_days_landsat
        - producttype_sentinel
    """
    fid, start_date, end_date, footprint = parse_shp(config.shp_file, event_id)
    
    print(f"\nSearching for {satellite} images for event ID {fid} between {start_date} and {end_date}")
    print(f"\nDownloading images is set to: {config.download_scenes}")

    # Footprint is an instance of <class 'shapely.geometry.multipolygon.MultiPolygon'>
    # from https://shapely.readthedocs.io/en/stable/manual.html:
    # footprint.bounds return the bounding box as a (minx, miny, maxx, maxy) tuple.
    # whereas the Landsat API expects footprint as a tuple in the form of (xmin, ymin, xmax, ymax)

    # Get the bounding box
    polygon = shapely.geometry.box(*footprint.bounds, ccw=True)

    if satellite == "sentinel":
        # Search parameters
        time_delta = config.delta_days_sentinel
        adjusted_start_date = start_date - timedelta(days=time_delta) 
        adjusted_end_date = end_date + timedelta(days=time_delta)

        adjusted_start_date = adjusted_start_date.isoformat() + 'Z'
        adjusted_end_date = adjusted_end_date.isoformat() + 'Z'

        product_type = config.producttype_sentinel
        max_cloud_cover = config.max_cloud_cover
        
        print(f"With the start date of: {adjusted_start_date} and end date of: {adjusted_end_date}")
        
        get_sentinel(fid, polygon.wkt, adjusted_start_date, adjusted_end_date, product_type, max_cloud_cover)
    
    elif satellite == "landsat":
        time_delta = config.delta_days_landsat
        adjusted_start_date = start_date - timedelta(days=time_delta) 
        adjusted_end_date = end_date + timedelta(days=time_delta)

        print(f"and with the start date of: {adjusted_start_date} and end date of: {adjusted_end_date}")

        get_landsat(fid,
                polygon.bounds,
                adjusted_start_date, 
                adjusted_end_date)

    else: 
        print("Wrong satellite selected. Exiting!")
        sys.exit()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Search for and download satellite images for a given fire event.")
    parser.add_argument("-id", "--event_id", type=str, help="ID of the fire event for which satellite images are to be searched. This comes from the id field of the fire events shapefile.")
    parser.add_argument("-s","--satellite", type=str, choices=["sentinel", "landsat"], help="Name of the satellite from which images are to be retrieved. Accepted values are 'sentinel' and 'landsat'.")
    args = parser.parse_args()
    main(args.event_id, args.satellite)